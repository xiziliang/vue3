<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    #canvas {
      background-color: #ccc;
    }
  </style>
  <body>
    <canvas id="canvas" width="512" height="512"> </canvas>
  </body>
  <script>
    /** @type {HTMLCanvasElement} */
    class Vector2D extends Array {
      constructor(x = 1, y = 0) {
        super(x, y);
      }
      get x() {
        return this[0];
      }
      get y() {
        return this[1];
      }
      set x(v) {
        return (this[0] = v);
      }
      set y(v) {
        return (this[1] = v);
      }
      get lengths() {
        console.log(this);
        return Math.hypot(this.x, this.y);
      }
      get dir() {
        return Math.atan2(this.y, this.x); //返回从原点(0,0)到(x,y)点的线段与x轴正方向之间的平面角度(弧度值)，也就是Math.atan2(y,x)
      }
      copy() {
        return new Vector2D(this.x, this.y);
      }
      add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      }
      sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
      scale(a) {
        this.x *= a;
        this.y *= a;
        return this;
      }
      //?
      cross(v) {
        return this.x * v.y - this.y * v, x;
      }
      // ?
      dot(v) {
        return this.x * v.x - this.y * v.y;
      }
      // 正常化
      normalize() {
        return this.scale(1 / this.lengths);
      }
      rotate(rad) {
        const c = Math.cos(rad), //对应度数的余弦值
          s = Math.sin(rad); // 对应度数的正弦值
        const [x, y] = this;
        this.x = x * c + y * -s; //?
        this.y = x * s + y * c; //?
        return this;
      }
    }

    const canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.lineCap = "round";
    function drawBranch(context, v0, length, weight, dir, bias) {
      // 上下文 起始向量 树长度 树宽度 树枝方向 随机偏向因子
      const v = new Vector2D(1, 0).rotate(dir).scale(length);
      const v1 = v0.copy().add(v);
      //   console.log("v1", v1);
      context.lineWidth = weight;
      context.beginPath();
      context.moveTo(...v0);
      context.lineTo(...v1);
      context.stroke();

      if (weight > 2) {
        const left = dir - 0.2;
        // const left =
        //   Math.PI / 4 + 0.5 * (dir + 0.2) + bias * (Math.random() - 0.5);
        drawBranch(context, v1, length * 0.9, weight * 0.8, left, bias + 0.9);
        const right = dir + 0.2;
        // const right =
        //   Math.PI / 4 + 0.5 * (dir - 0.2) + bias * (Math.random() - 0.5);
        drawBranch(context, v1, length * 0.9, weight * 0.8, right, bias + 0.9);
      }

      if (weight < 5 && Math.random() < 0.3) {
        context.save();
        const th = Math.random() * 6 + 3; // 把点放大
        context.lineWidth = th;
        context.beginPath();
        console.log("v1", ...v1);
        context.moveTo(...v1);
        context.lineTo(v1.x, v1.y - 1);
        context.strokeStyle = "#c72c35";
        context.stroke();
        context.restore();
      }
    }
    const v0 = new Vector2D(256, 0);
    drawBranch(ctx, v0, 50, 10, Math.PI / 2, 3);

    // v.x; // 在赋值是只调用set 在读取值时只调用get
  </script>
</html>
